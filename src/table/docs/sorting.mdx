import { Meta, Source, Canvas, Controls } from '@storybook/blocks'

<Meta title="Data Display/Object Set Table/Docs/Sorting" />

# Sorting & Reordering

Sorting lets users order rows by any column you mark as sortable. Sorting is configured per-column and works via header clicks or programmatic API calls. Additionally, the table supports drag-and-drop row reordering for manual row arrangement. This page focuses on how to enable and customize both sorting and reordering for `ObjectSetTable`.

## Sorting configuration

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `sortable` | `boolean` | `false` | Enables header click-to-sort for the column. |
| `rowComparator` | `(a: unknown, b: unknown, context: SortableColumnContext<T>) => number` | Type-based comparator | Compare two values returned by the column's `valueGetter`. Return `< 0`, `0`, or `> 0`. |
| `onSort` | `(context: SortableColumnContext<T>) => void` | `undefined` | Called after sorting changes (including when sorting is cleared). |

For a full list of column properties, see [Column Definition](?path=/docs/data-display-object-set-table-docs-column-definition--readme).

## Basic usage

```tsx
const columns = [
  { field: 'name', title: 'Name', sortable: true },
  { field: 'amount', title: 'Amount', type: 'number', sortable: true },
]

<ObjectSetTable data={data} columns={columns} />
```

Header interaction cycles through: Asc → Desc → None. A sort indicator appears when `sortable` is `true`.

## Defaults and behavior

- **Default comparators**: Each column type has a built-in comparator optimized for that data type.
- **Null handling**: `null` values are placed at the end when sorting.
- **Unsorted state**: Clearing sort restores the original row order.
- **Value source**: Comparisons use values from the column `valueGetter`. To sort by a computed value, provide a custom `valueGetter` in your column. See [Column Definition](?path=/docs/data-display-object-set-table-docs-column-definition--readme).

## Custom comparator

Use `rowComparator` for custom rules (e.g., case-insensitive text, domain-specific ordering):

```tsx
const columns = [
  {
    field: 'category',
    sortable: true,
    rowComparator: (a, b, context) => {
      // Simple case-insensitive comparison
      return String(a ?? '').localeCompare(String(b ?? ''), undefined, { sensitivity: 'base' })
    },
  },
  {
    field: 'priority',
    sortable: true,
    rowComparator: (a, b, context) => {
      // Use context for more complex sorting logic
      const { sortState, columnDef, data } = context
      
      // Custom priority ordering: high -> medium -> low
      const priorityOrder = { high: 3, medium: 2, low: 1 }
      const aValue = priorityOrder[a as keyof typeof priorityOrder] ?? 0
      const bValue = priorityOrder[b as keyof typeof priorityOrder] ?? 0
      
      // Access sort direction for custom behavior
      const multiplier = sortState?.direction === 'desc' ? -1 : 1
      return (aValue - bValue) * multiplier
    },
  },
]
```

## SortableColumnContext

Both `rowComparator` and `onSort` functions receive a `SortableColumnContext` object with rich information about the sorting operation:

| Property | Type | Description |
|----------|------|-------------|
| `tableConfig` | `ObjectSetTableConfig<T>` | The complete table configuration including all columns, data, and settings. |
| `columnDef` | `ColumnDef<T>` | The column definition for the column being sorted. |
| `data` | `T[]` | The current data array. In `onSort`, this is the newly sorted data. In `rowComparator`, this is the original data. |
| `sortState` | `SortState \| null` | Current sort information with `columnIndex` and `direction` ('asc' or 'desc'), or `null` when sorting is cleared. |

### SortState properties

| Property | Type | Description |
|----------|------|-------------|
| `columnIndex` | `number` | The index of the column being sorted (0-based). |
| `direction` | `'asc' \| 'desc'` | The sort direction. |

### Context usage scenarios

The `SortableColumnContext` enables advanced sorting behaviors:

- **Multi-column awareness**: Access `tableConfig.columns` to implement sorting that considers other columns
- **Data-driven sorting**: Use the full `data` array to implement relative comparisons (e.g., percentile-based sorting)
- **Conditional logic**: Check `sortState.direction` to customize ascending vs descending behavior
- **Cross-column dependencies**: Use `columnDef` to access the current column's configuration and adapt sorting accordingly
- **State management**: In `onSort`, access the newly sorted `data` to update external state or trigger side effects

## Sort callbacks

Use `onSort` for side effects (analytics, remote queries, UI updates):

```tsx
const columns = [
  {
    field: 'amount',
    title: 'Amount',
    type: 'number',
    sortable: true,
    onSort: ({ sortState, columnDef, data, tableConfig }) => {
      // sortState is { columnIndex, direction } or null when cleared
      console.log('Sorted by', columnDef.field, '->', sortState)
      
      // Access the sorted data
      console.log('First sorted row:', data[0])
      
      // Access other table configuration
      console.log('Total columns:', tableConfig.columns.length)
      
      // Trigger analytics or remote updates
      if (sortState) {
        analytics.track('table_sorted', {
          column: columnDef.field,
          direction: sortState.direction,
          rowCount: data.length
        })
      }
    },
  },
]
```

## Programmatic control

You can sort via the table API using `apiRef`. See the [API docs](?path=/docs/data-display-object-set-table-docs-api--readme#sorting-api) for more.

```tsx
const apiRef = useRef<TableApiBase>(null)

<ObjectSetTable data={data} columns={columns} apiRef={apiRef} />

// Sort first column ascending
apiRef.current?.sortRows(0, 'asc')

// Clear sorting
apiRef.current?.sortRows(0, null)

// Read current sort info
const info = apiRef.current?.getCurrentSortInfo() // { columnIndex, direction } | null
```

## Row reordering

Row reordering provides an alternative to sorting by enabling manual drag-and-drop arrangement of table rows. When enabled, users can drag rows to reposition them within the table.

### Configuration

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `onReorder` | `(rows: T[], targetRowIndex: number) => Promise<void> \| void` | `undefined` | Function called when rows are reordered. Enables drag-and-drop reordering when provided. |

### Basic usage

```tsx
const [data, setData] = useState(originalData)

const handleReorder = (rows: Person[], targetRowIndex: number) => {
  setData((prevData) => {
    // Extract rows that are not being moved
    const left: Person[] = []
    const right: Person[] = []

    prevData.forEach((row, index) => {
      if (!rows.some((incomingRow) => incomingRow.id === row.id)) {
        if (index <= targetRowIndex) {
          left.push(row)
        } else {
          right.push(row)
        }
      }
    })

    // Insert the reordered rows at the target position
    return [...left, ...rows, ...right]
  })
}

const columns = [
  { field: 'name', title: 'Name' },
  { field: 'email', title: 'Email' },
  // Note: No sortable: true here
]

<ObjectSetTable 
  data={data} 
  columns={columns} 
  onReorder={handleReorder}
/>
```

### Reorder behavior

- **Drag handle**: Rows become draggable when `onReorder` is provided
- **Multi-row support**: Selected rows can be reordered together
- **Visual feedback**: Drag indicators show valid drop zones
- **Target index**: The `targetRowIndex` is relative to the original array position

### ⚠️ Important: Conflict with sorting

**Row reordering and column sorting are mutually exclusive features.** You cannot use both simultaneously:

```tsx
// ❌ This will cause a conflict warning
const columns = [
  { field: 'name', sortable: true }, // sortable: true
]

<ObjectSetTable 
  data={data} 
  columns={columns} 
  onReorder={handleReorder} // Cannot use with sortable columns
/>
```

```tsx
// ✅ Choose one approach
// Option 1: Use sorting only
const columns = [
  { field: 'name', sortable: true },
]
<ObjectSetTable data={data} columns={columns} />

// Option 2: Use reordering only  
const columns = [
  { field: 'name' }, // no sortable property
]
<ObjectSetTable data={data} columns={columns} onReorder={handleReorder} />
```

**Why the conflict exists**: Sorting automatically reorders rows based on data values, while manual reordering preserves user-defined order. These two approaches fundamentally conflict with each other's row positioning logic.

---

## Related docs

- [Column Definition](?path=/docs/data-display-object-set-table-docs-column-definition--readme): sorting props (`sortable`, `rowComparator`, `onSort`), value pipeline
- [API](?path=/docs/data-display-object-set-table-docs-api--readme): programmatic sorting methods
