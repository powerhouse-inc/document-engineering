import { Meta, Source, Canvas, Controls } from '@storybook/blocks'

<Meta title="Data Display/Object Set Table/Docs/Cell Editors" />

# Cell Editors

Cell editors are the input fields that appear when editing a table cell. The `ObjectSetTable` provides built-in cell editors for common data types, along with builder functions that let you customize these editors with the same props as their equivalent scalar components.

## Quick Reference

### Basic Editors

- **String**: `buildStringCellEditor` - Text input
- **Number**: `buildNumberCellEditor` - Number input
- **Boolean**: `buildBooleanCellEditor` - Checkbox/toggle
- **Enum**: `buildEnumCellEditor` - Dropdown select

### Date & Time Editors

- **Date**: `buildDateCellEditor` - Date picker
- **DateTime**: `buildDateTimeCellEditor` - Date and time picker
- **Time**: `buildTimeCellEditor` - Time picker

### Specialized Editors

- **Email**: `buildEmailCellEditor` - Email input with validation
- **URL**: `buildUrlCellEditor` - URL input with validation
- **Country**: `buildCountryCellEditor` - Country code selector
- **Currency**: `buildCurrencyCellEditor` - Currency code selector
- **Amount**: `buildAmountCellEditor` - Amount with currency
- **PHID**: `buildPhidCellEditor` - PHID input
- **OID**: `buildOidCellEditor` - Object ID input
- **AID**: `buildAidCellEditor` - Account ID input

## How to Use

### 1. Import the builder

```tsx
import { buildStringCellEditor, buildNumberCellEditor } from '@powerhousedao/document-engineering/table'
```

### 2. Configure with scalar props

```tsx
const columns = [
  {
    field: 'firstName',
    title: 'First Name',
    editable: true,
    renderCellEditor: buildStringCellEditor({
      maxLength: 20,
      placeholder: 'Enter first name',
    }),
  },
  {
    field: 'age',
    title: 'Age',
    editable: true,
    renderCellEditor: buildNumberCellEditor({
      minValue: 0,
      maxValue: 120,
      step: 1,
    }),
  },
]
```

### 3. Handle saving

```tsx
{
  field: 'firstName',
  editable: true,
  renderCellEditor: buildStringCellEditor({ maxLength: 20 }),
  onSave: (value, context) => {
    if (typeof value === 'string' && value.length > 0) {
      context.row.firstName = value
      return true // Commit the change
    }
    return false // Reject the change
  }
}
```

## Automatic Editor Selection

If you don't specify a `renderCellEditor`, the table automatically selects an editor based on the column's `type`:

```tsx
const columns = [
  {
    field: 'name',
    type: 'string', // Uses buildStringCellEditor({})
    editable: true,
  },
  {
    field: 'size',
    type: 'number', // Uses buildNumberCellEditor({})
    editable: true,
  },
]
```

## Builder Reference

All builders accept the same props as their equivalent scalar components. See the individual scalar component documentation for available props.

| Builder                   | Component           |
| ------------------------- | ------------------- |
| `buildStringCellEditor`   | StringField         |
| `buildNumberCellEditor`   | NumberField         |
| `buildBooleanCellEditor`  | BooleanField        |
| `buildEnumCellEditor`     | EnumField           |
| `buildDateCellEditor`     | DatePickerField     |
| `buildDateTimeCellEditor` | DateTimePickerField |
| `buildTimeCellEditor`     | TimePickerField     |
| `buildEmailCellEditor`    | EmailField          |
| `buildUrlCellEditor`      | UrlField            |
| `buildCountryCellEditor`  | CountryCodeField    |
| `buildCurrencyCellEditor` | CurrencyCodeField   |
| `buildAmountCellEditor`   | AmountField         |
| `buildPhidCellEditor`     | PhidField           |
| `buildOidCellEditor`      | OidField            |
| `buildAidCellEditor`      | AidField            |

## Custom Cell Editors

The table system provides built-in cell editors for common data types, but you can create custom cell editors for specialized use cases.

### Understanding the Architecture

Cell editors in this table system are built on a three-layer architecture:

1. **Scalar Components**: Base form field components (StringField, NumberField, etc.)
2. **Form Integration**: All editors work within a react-hook-form context
3. **Table Integration**: Editors are wrapped in a Form component within each table cell

### Custom Cell Editor Function Signature

```tsx
type RenderCellEditorFn<TData extends DataType, TCellValue> = (
  value: TCellValue,                    // Current cell value
  onChange: (newValue: TCellValue) => void, // Update function  
  context: CellContext<TData>          // Cell context with row, column, table info
) => React.ReactNode
```

### Key Requirements for Custom Editors

#### 1. Must be Controlled Components
Cell editors must accept `value` and `onChange` props to work properly:

#### 2. Must Use the `field` as the `name` Prop
The `name` prop must match the column's `field` property for react-hook-form integration:

#### 3. Must Work Inside Form Component
All cell editors are wrapped in a Form component that uses react-hook-form. Your custom editor must be compatible with this form context.

### Using Any Input Library with React Hook Form

For components that are not part of this library's scalar system, you can use the `register` function from react-hook-form. Since all cell editors are wrapped in a Form component, you have access to the react-hook-form context.

#### Basic HTML Input Example

```tsx
import { useFormContext } from 'react-hook-form'
import { cn, type CellContext } from '@powerhousedao/document-engineering/table'

const CustomTextInputEditor = ({
  value,
  onChange,
  context,
  placeholder,
  maxLength,
}: {
  value: unknown
  onChange: (newValue: unknown) => void
  context: CellContext<YourDataType>
  placeholder?: string
  maxLength?: number
}) => {
  const { register } = useFormContext()
  const inputValue = typeof value === 'string' ? value : (value?.toString() ?? '')

  return (
    <input
      {...register(context.column.field, {
        // value and onChange are required in order to work properly
        value: inputValue,
        onChange,
        // you can use react-hook-form built-in validation, it itegrates automatically with the table
        validate: (value) => {
          if (typeof value === 'string' && value.length > 10) {
            return 'Value must be less than 10 characters'
          }
          return true
        },
      })}
      type="text"
      placeholder={placeholder}
      autoFocus
      className={cn(
        'w-full px-2 py-1 text-sm border border-gray-300 rounded-md',
        'focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent',
        'bg-white text-gray-900 placeholder-gray-500'
      )}
    />
  )
}
```

#### Creating Builder Functions

Editors can be created using the cell editor signature directly, but creating builders gives you the flexibility to reuse them with different parameters:

```tsx
const buildCustomHTMLInputEditor = (placeholder?: string, maxLength?: number) => {
  const editor = (value: unknown, onChange: (newValue: unknown) => void, context: CellContext<YourDataType>) => {
    return (
      <CustomTextInputEditor
        value={value}
        onChange={onChange}
        context={context}
        placeholder={placeholder}
        maxLength={maxLength}
      />
    )
  }
  editor.displayName = 'CustomHTMLInputEditor'
  return editor
}

// Usage in column definition
const columns = [
  {
    field: 'firstName',
    title: 'First Name',
    editable: true,
    renderCellEditor: buildCustomHTMLInputEditor('Enter first name...', 50),
    onSave: (value, context) => {
      if (typeof value === 'string' && value.trim().length > 0) {
        context.row.firstName = value.trim()
        return true
      }
      return false
    }
  }
]
```

> **ðŸ’¡ See it in action:** Check out the [Custom Cell Editors Example](/docs/data-display-object-set-table-examples-custom-cell-editors--default) for a complete working implementation.

### Key Points for Custom Editors

#### Use React Hook Form Features
- Leverage `register()` for form integration and validation
- Use validation rules like `pattern`, `validate`, `min`, `max`, etc.
- Access form context with `useFormContext()`

#### Consider User Experience
- Always include `autoFocus` for immediate editing
- Provide helpful placeholders and appropriate input types
- Use proper styling and accessibility attributes



## Related Documentation

- [Editing](/docs/data-display-object-set-table-docs-editing--readme): General editing concepts
- [Column Definition](/docs/data-display-object-set-table-docs-column-definition--readme): Column configuration
- [Cells](/docs/data-display-object-set-table-docs-cells--readme): Cell rendering
- [Keyboard Shortcuts](/docs/data-display-object-set-table-docs-keyboard-shortcuts--readme): Editing interactions
